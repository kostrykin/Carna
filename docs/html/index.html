<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Carna: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doc_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Carna
   &#160;<span id="projectnumber">Version 3.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Carna Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Carna provides classes for simple and fast visualization of CT data. It is named after the greek god of organs (yup, they really did have even one for organs). It is based on OpenGL 3.3 and Eigen 3.</p>
<p>Jump to: <a class="el" href="index.html#QuickStart">Quick Start</a> | <a class="el" href="VersionLog.html">API 3.x Version Log</a> | <a class="el" href="namespaceCarna_1_1testing.html">Test Suite Documentation</a> </p><hr/>
<ol type="1">
<li><a class="el" href="index.html#QuickStart_FrameRenderer">The Frame Renderer</a>: <a class="el" href="index.html#RenderStages">Built-in Rendering Stages</a> and <a class="el" href="index.html#GeometryTypes">Geometry Types</a></li>
<li><a class="el" href="index.html#SceneGraph">The Scene Graph</a>: <a class="el" href="index.html#SceneGraph_SpecialSpatialClasses">Spatial Class Specializations</a> and <a class="el" href="index.html#QuickStart_VolumeGridHelper">Positioning CT Data</a></li>
<li><a class="el" href="index.html#GeometryFeatures">Geometry Features</a>: <a class="el" href="index.html#GeometryFeatureLifecycle">The Lifecycle of Geometry Features</a> and <a class="el" href="index.html#QuickStart_Materials">Materials</a></li>
</ol>
<div class="image">
<img src="typical.png" alt="typical.png"/>
<div class="caption">
rendering result from example code below</div></div>
 <h1><a class="anchor" id="QuickStart"></a>
Quick Start</h1>
<ol type="1">
<li>Implement the abstract <a class="el" href="classCarna_1_1base_1_1GLContext.html">base::GLContext</a> class. If you're using Qt, you can simply instantiate the <a class="el" href="classCarna_1_1base_1_1QGLContextAdapter.html">base::QGLContextAdapter</a> template.</li>
<li>Instantiate and configure a <a class="el" href="classCarna_1_1base_1_1FrameRenderer.html">base::FrameRenderer</a>, e.g. like this: <div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GEOMETRY_TYPE_VOLUMETRIC = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GEOMETRY_TYPE_PLANE      = 1;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GEOMETRY_TYPE_OPAQUE     = 2;</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespaceCarna.html">Carna</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classCarna_1_1base_1_1FrameRenderer.html">base::FrameRenderer</a> fr( glContext, 800, 600, <span class="keyword">true</span> );</div><div class="line">    <a class="code" href="classCarna_1_1helpers_1_1FrameRendererHelper.html">helpers::FrameRendererHelper&lt; &gt;</a> frHelper( fr );</div><div class="line">    frHelper &lt;&lt; <span class="keyword">new</span> <a class="code" href="classCarna_1_1presets_1_1CuttingPlanesStage.html">presets::CuttingPlanesStage</a>( GEOMETRY_TYPE_VOLUMETRIC, GEOMETRY_TYPE_PLANE );</div><div class="line">    frHelper &lt;&lt; <span class="keyword">new</span> <a class="code" href="namespaceCarna_1_1presets.html#a544f1850fe5eb21b67d35bec55e6a9dd">presets::OpaqueRenderingStage</a>( GEOMETRY_TYPE_OPAQUE );</div><div class="line">    frHelper &lt;&lt; <span class="keyword">new</span> <a class="code" href="classCarna_1_1presets_1_1DRRStage.html">presets::DRRStage</a>( GEOMETRY_TYPE_VOLUMETRIC );</div><div class="line">    frHelper &lt;&lt; <span class="keyword">new</span> <a class="code" href="classCarna_1_1presets_1_1OccludedRenderingStage.html">presets::OccludedRenderingStage</a>();</div><div class="line">    frHelper.commit();</div><div class="line"></div><div class="line">    fr.findStage&lt; <a class="code" href="classCarna_1_1presets_1_1CuttingPlanesStage.html">presets::CuttingPlanesStage</a> &gt;()-&gt;setWindowingWidth( 2000 );</div><div class="line">    fr.findStage&lt; <a class="code" href="classCarna_1_1presets_1_1CuttingPlanesStage.html">presets::CuttingPlanesStage</a> &gt;()-&gt;setRenderingInverse( <span class="keyword">true</span> );</div><div class="line">    fr.findStage&lt; <a class="code" href="classCarna_1_1presets_1_1DRRStage.html">presets::DRRStage</a> &gt;()-&gt;setRenderingInverse( <span class="keyword">true</span> );</div><div class="line">    fr.setBackgroundColor( <a class="code" href="classCarna_1_1base_1_1Color.html#a6612fc7554d76caa3a528539b52fa7fa">base::Color::WHITE_NO_ALPHA</a> );</div></div><!-- fragment --> The values of the <code>GEOMETRY_TYPE_</code> variables can be chosen arbitrary, but must be distinct.</li>
<li>Assuming you have somehow loaded <code>data</code> and know the voxel <code>spacings</code>, build the <a class="el" href="index.html#SceneGraph">scene graph</a>, e.g. like this: <div class="fragment"><div class="line">    base::Node root;</div><div class="line"></div><div class="line">    <span class="comment">/* Configure camera.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    base::Camera* <span class="keyword">const</span> cam = <span class="keyword">new</span> base::Camera();</div><div class="line">    cam-&gt;localTransform = <a class="code" href="namespaceCarna_1_1base_1_1math.html#a3246cff6fc2583608d1d22acbb301937">base::math::rotation4f</a>( 0, 1, 0, <a class="code" href="namespaceCarna_1_1base_1_1math.html#ae56685f515809184a2e23209a1a33c13">base::math::deg2rad</a>( 20 ) ) * <a class="code" href="namespaceCarna_1_1base_1_1math.html#af5019979ecc61c5cb518f9722b190394">base::math::translation4f</a>( 0, 0, 350 );</div><div class="line">    cam-&gt;setProjection( <a class="code" href="namespaceCarna_1_1base_1_1math.html#a64f454a89a9328ab303319f6072cf7a5">base::math::frustum4f</a>( <a class="code" href="namespaceCarna_1_1base_1_1math.html#ae56685f515809184a2e23209a1a33c13">base::math::deg2rad</a>( 45 ), 1, 10, 2000 ) );</div><div class="line">    root.attachChild( cam );</div><div class="line"></div><div class="line">    <span class="comment">/* Configure geometry node for volume data.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">typedef</span> helpers::VolumeGridHelper&lt; base::HUVolumeUInt16 &gt; UInt16HUGridHelper;</div><div class="line">    UInt16HUGridHelper gridHelper( data.size );</div><div class="line">    gridHelper.loadData( data );</div><div class="line">    root.attachChild( gridHelper.createNode( GEOMETRY_TYPE_VOLUMETRIC, UInt16HUGridHelper::Spacing( spacings ) ) );</div><div class="line"></div><div class="line">    <span class="comment">/* Configure cutting planes.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    base::Geometry* <span class="keyword">const</span> plane1 = <span class="keyword">new</span> base::Geometry( GEOMETRY_TYPE_PLANE );</div><div class="line">    plane1-&gt;localTransform = <a class="code" href="namespaceCarna_1_1base_1_1math.html#a68b06e0e39f2b71b96ab966aef5976ff">base::math::plane4f</a>( <a class="code" href="namespaceCarna_1_1base_1_1math.html#a5514f9471eeafc285ab52b33f1c79cec">base::math::Vector3f</a>( 1, 1, 1 ).normalized(), 0 );</div><div class="line">    root.attachChild( plane1 );</div><div class="line"></div><div class="line">    <span class="comment">/* Configure opaque geometries.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    base::ManagedMeshBase&amp; boxMesh = <a class="code" href="classCarna_1_1base_1_1MeshFactory.html#acac7c62e90744138576e18dd7496f6aa">base::MeshFactory&lt; base::VertexBase &gt;::createBox</a>( 40, 40, 40 );</div><div class="line">    base::Material&amp; boxMaterial = <a class="code" href="classCarna_1_1base_1_1Material.html#a171cf4340cdda88f4e304e86934cd667">base::Material::create</a>( <span class="stringliteral">&quot;unshaded&quot;</span> );</div><div class="line">    boxMaterial.setParameter( <span class="stringliteral">&quot;color&quot;</span>, <a class="code" href="classCarna_1_1base_1_1Color.html#a28175c253a2e98e62537ad35eef17ff9">base::Color::GREEN</a> );</div><div class="line">    base::Geometry* <span class="keyword">const</span> boxGeometry = <span class="keyword">new</span> base::Geometry( GEOMETRY_TYPE_OPAQUE );</div><div class="line">    boxGeometry-&gt;putFeature( <a class="code" href="classCarna_1_1base_1_1MeshRenderingStageBase.html#af2f3f389e4757501a3be3c8751131a79">presets::OpaqueRenderingStage::ROLE_DEFAULT_MATERIAL</a>, boxMaterial );</div><div class="line">    boxGeometry-&gt;putFeature( <a class="code" href="classCarna_1_1base_1_1MeshRenderingStageBase.html#a5358a537a3fe04ff0d2a38e9c0da1ebf">presets::OpaqueRenderingStage::ROLE_DEFAULT_MESH</a>, boxMesh );</div><div class="line">    boxGeometry-&gt;localTransform = <a class="code" href="namespaceCarna_1_1base_1_1math.html#af5019979ecc61c5cb518f9722b190394">base::math::translation4f</a>( 0, -15, 0 );</div><div class="line">    root.attachChild( boxGeometry );</div><div class="line"></div><div class="line">    <span class="comment">/* Release geometry features.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    boxMesh.release();</div><div class="line">    boxMaterial.release();</div><div class="line">    gridHelper.releaseGeometryFeatures();</div></div><!-- fragment --></li>
<li>Issue the <a class="el" href="classCarna_1_1base_1_1FrameRenderer.html#acd6455a7298621c501f4cb55fd348d03">base::FrameRenderer::render</a> method: <div class="fragment"><div class="line">    fr.render( *cam );</div></div><!-- fragment --> This code produces the rendering above. <hr/>
</li>
</ol>
<p>Now lets take a closer look at what the code presented above actually does.</p>
<h2><a class="anchor" id="QuickStart_FrameRenderer"></a>
The Frame Renderer</h2>
<p>The <code>FrameRenderer</code> consists of multiple components, each of which defines a particular aspect of the rendering logic. Those components are called <em>rendering stages</em> because their rendering logic is executed sequentially. The rendering results depends heavily on the stages order. There is no generally "correct" order, because this always depends on what one actually expects. The <code>FrameRendererHelper</code> class assumes a <a class="el" href="classCarna_1_1helpers_1_1DefaultRenderStageOrder.html">default order</a> that will lead to the desired results in presumably almost all cases. Of course one could also leave out this helper and add the stages to the renderer in any desired order manually.</p>
<dl class="section see"><dt>See also</dt><dd>The rendering process is explained <a class="el" href="classCarna_1_1base_1_1FrameRenderer.html#RenderingProcess">here</a> in detail.</dd></dl>
<h3><a class="anchor" id="RenderStages"></a>
Built-in Rendering Stages</h3>
<p>In the example code above, several typical rendering stages are used:</p>
<ul>
<li>The <a class="el" href="classCarna_1_1presets_1_1CuttingPlanesStage.html">presets::CuttingPlanesStage</a> renders an arbitrary number of cutting planes through volume data.</li>
<li>The <a class="el" href="namespaceCarna_1_1presets.html#a544f1850fe5eb21b67d35bec55e6a9dd">presets::OpaqueRenderingStage</a> renders opaque meshes, i.e. polygonal geometry.</li>
<li>The <a class="el" href="classCarna_1_1presets_1_1DRRStage.html">presets::DRRStage</a> produces a <em>digital radiograph reconstruct</em> of the volume data.</li>
<li>The <a class="el" href="classCarna_1_1presets_1_1OccludedRenderingStage.html">presets::OccludedRenderingStage</a> ensures that meshes, that are actually occluded by other geometry that is closer to the viewer, shine through.</li>
</ul>
<p>At the moment the following other stages are available out-of-the-box:</p>
<ul>
<li>The <a class="el" href="classCarna_1_1presets_1_1MeshColorCodingStage.html">presets::MeshColorCodingStage</a> implements a simple interface for mapping <a class="el" href="CoordinateSystems.html#FrameCoordinates">frame coordinates</a> to <a class="el" href="classCarna_1_1base_1_1Mesh.html">base::Mesh</a> objects.</li>
<li>The <a class="el" href="classCarna_1_1presets_1_1MIPStage.html">presets::MIPStage</a> implements <em>maximum intensity projections</em> of volume data.</li>
<li>The <a class="el" href="classCarna_1_1presets_1_1DVRStage.html">presets::DVRStage</a> renders volume data through application of an HUV to color transfer function.</li>
<li>The <a class="el" href="classCarna_1_1presets_1_1ParallaxStage.html">presets::ParallaxStage</a> produces stereoscopic renderings.</li>
<li>The <a class="el" href="classCarna_1_1presets_1_1TransparentRenderingStage.html">presets::TransparentRenderingStage</a> renders transparent meshes.</li>
</ul>
<h3><a class="anchor" id="GeometryTypes"></a>
Geometry Types</h3>
<p>As one may guess from this list, each scene might contain multiple types of renderable objects. At least one could distinguish between polygonal and volumetric objects. Planes are certainly a third type: They are neither polygonal because they are infinitely extended, nor they are volumetric. This is the very breakdown that was used in the example, but it is up to the user to choose a more detailed classification if required. Note that each rendering stage expects to be told which <em>geometry type</em> it should render. By using two <code>CuttingPlanesStage</code> instances with different geometry types for example, one could render multiple cutting planes with different windowing settings.</p>
<h2><a class="anchor" id="SceneGraph"></a>
The Scene Graph</h2>
<p>Carna represents spatial entities with instances of the <code>Spatial</code> class. Such entities can be renderable objects, as well as imaginary points in space. The location of each spaital entity is determined relatively to another one that is called its <em>parent</em>. This parent-child relationship induces a tree structure, that is commonly referred to as <em>scene</em> <em>graph</em>. Such a scene graph represents a scene. This has two implications: First, that each scene contains exactly one node that has no parent, namely the tree's root. Second, that it is sufficient to specify an arbitrary node in order to reach any other <code>Spatial</code> of the scene.</p>
<h3><a class="anchor" id="SceneGraph_SpecialSpatialClasses"></a>
Spatial Class Specializations</h3>
<p>The specific type of a <code>Spatial</code> decides upon whether it is an inner node or a leaf of the scene graph. If it is <em>allowed</em> to have children, the spatial entity will be realized by an instance of the <a class="el" href="classCarna_1_1base_1_1Node.html">base::Node</a> class, even if it has no children in a particular situation. In contrast, visible scene elements, i.e. such that can be rendered, must always be leafs. They will be realized by instances of the <a class="el" href="classCarna_1_1base_1_1Geometry.html">base::Geometry</a> class usually. Another leaf type is the <code>Camera</code> that not only has a location within the scene, but also specifies how the 3D space is to be projected into 2D.</p>
<p>It should be clear from the above why the root of a scene graph always is a <a class="el" href="classCarna_1_1base_1_1Node.html">base::Node</a> instance. The coordinate system of the root is often called <em>world space</em>. You can read more on the different coordinate systems and how they are related to each other <a class="el" href="CoordinateSystems.html">here</a>.</p>
<dl class="section see"><dt>See also</dt><dd>Following classes simplify the <code>Camera</code> handling: <a class="el" href="classCarna_1_1presets_1_1PerspectiveControl.html">presets::PerspectiveControl</a>, <a class="el" href="classCarna_1_1presets_1_1CameraShowcaseControl.html">presets::CameraShowcaseControl</a>, <a class="el" href="classCarna_1_1presets_1_1CameraNavigationControl.html">presets::CameraNavigationControl</a></dd>
<dd>
The <a class="el" href="classCarna_1_1base_1_1SpatialMovement.html">base::SpatialMovement</a> class makes the implementation of drag-&amp;-drop like behaviour for <code>Geometry</code> objects very easy.</dd></dl>
<h3><a class="anchor" id="QuickStart_VolumeGridHelper"></a>
Positioning CT Data</h3>
<p>The <code>VolumeGridHelper</code> class takes care of two things. First, it partitions the volumetric <code>data</code> into multiple smaller, box-shaped volumes. This partitioning is done according to an upper limit of each volume's memory size. It reduces the probability of out-of-memory exceptions due to memory fragmentation. In the example no specific limit is set, thus the <a class="el" href="classCarna_1_1helpers_1_1VolumeGridHelperBase.html#a92ef4e813da3e881b2c8d015cfe0dd1d">default</a> is used. Second, the <code>VolumeGridHelper</code> class creates a scene <code>Node</code> that represents the partitioned <code>data</code> within the scene. This <code>Node</code> has one <code>Geometry</code> child per volume partition.</p>
<h2><a class="anchor" id="GeometryFeatures"></a>
Geometry Features</h2>
<p>Each <code>Geometry</code> node is rendered by the rendering stage with a matching geometry type. Usually that rendering stage will query particular <em>features</em> from this <code>Geometry</code> object: Features are like components that make up the <code>Geometry</code> object in its entirety, but the <code>Geometry</code> object <em>aggregates</em> them, i.e. does not take their possession. This allows the same feature to be reused many times across the scene, or even across many scenes. Rendering stages identify features through the <em>roles</em> they take when associated with a <code>Geometry</code> object.</p>
<p>The geometry features API is documented <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html">here</a>.</p>
<h3><a class="anchor" id="GeometryFeatureLifecycle"></a>
The Lifecycle of Geometry Features</h3>
<p>Because of their shared-use nature, the lifecycle of geometry features is worth taking a look at. They have neither a public constructor, nor a public destructor:</p>
<ul>
<li>Geometry features are acquired using their static <code>::create</code> function. Conventionally, Carna uses pointers in method interfaces when the object possession is transferred and C++ references when it is not. Each feature possess <em>itself</em>, hence that functions return references.</li>
<li>If you invoke <code>release</code> on the feature right after its creation, it will be deleted immediately because its unused.</li>
<li>By putting the feature on a <code>Geometry</code> object, the feature notices that it got attached. You may <code>release</code> it now, but it will not be deleted until the <code>Geometry</code> object it is attached to also dies.</li>
</ul>
<p>The idea is that the user invokes <code>release</code> on the feature as soon as it is sure that the feature is not going to be attached to any <em>further</em> <code>Geometry</code> objects. The feature object is leaked when it never is released, in which case you will also get an error message on the <a class="el" href="classCarna_1_1base_1_1Log.html">log</a> output.</p>
<h3><a class="anchor" id="QuickStart_Materials"></a>
Materials</h3>
<p>Materials determine how polygonal geometries are rendered. The core part of each material is a <a class="el" href="classCarna_1_1base_1_1ShaderProgram.html">shader</a>. Besides that, it can also have a set of parameters that will be uploaded to the shader when the material is applied, and it could enforce a particular <a class="el" href="classCarna_1_1base_1_1RenderState.html">OpenGL render state</a>.</p>
<p>There are a few material shaders available out-of-the-box:</p>
<ul>
<li>The <code>unshaded</code> material shader colors the rendered mesh in a single color uniformly.</li>
<li>The <a class="el" href="classCarna_1_1helpers_1_1PointMarkerHelper.html">helpers::PointMarkerHelper</a> class uses the <code>pointmarker</code> material shader to create simple markers in 3D space.</li>
</ul>
<p>The creation of custom materials is explained <a class="el" href="classCarna_1_1base_1_1Material.html#CustomMaterials">here</a>. </p>
</div></div><!-- contents -->
<hr class="footer"/>
    <address class="footer">
        <small>
			Written by <a href="http://evoid.de">Leonid Kostrykin</a> at the
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>
</body>
</html>
