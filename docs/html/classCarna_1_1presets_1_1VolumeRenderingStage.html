<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Carna: Carna::presets::VolumeRenderingStage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doc_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Carna
   &#160;<span id="projectnumber">Version 3.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Carna</b></li><li class="navelem"><a class="el" href="namespaceCarna_1_1presets.html">presets</a></li><li class="navelem"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html">VolumeRenderingStage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classCarna_1_1presets_1_1VolumeRenderingStage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Carna::presets::VolumeRenderingStage Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines abstract base class for <a class="el" href="classCarna_1_1base_1_1RenderStage.html">rendering stages</a> that render volume geometries in the scene.  
 <a href="classCarna_1_1presets_1_1VolumeRenderingStage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VolumeRenderingStage_8h_source.html">VolumeRenderingStage.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Carna::presets::VolumeRenderingStage:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classCarna_1_1presets_1_1VolumeRenderingStage__inherit__graph.png" border="0" usemap="#Carna_1_1presets_1_1VolumeRenderingStage_inherit__map" alt="Inheritance graph"/></div>
<map name="Carna_1_1presets_1_1VolumeRenderingStage_inherit__map" id="Carna_1_1presets_1_1VolumeRenderingStage_inherit__map">
<area shape="rect" id="node4" href="classCarna_1_1presets_1_1DRRStage.html" title="Renders digital radiograph reconstructs of volume geometries in the scene. " alt="" coords="789,5,969,32"/>
<area shape="rect" id="node5" href="classCarna_1_1presets_1_1DVRStage.html" title="Performs direct volume renderings of the volume geometries in the scene. " alt="" coords="790,56,969,83"/>
<area shape="rect" id="node6" href="classCarna_1_1presets_1_1MaskRenderingStage.html" title="Renders 3D masks. " alt="" coords="776,107,983,149"/>
<area shape="rect" id="node7" href="classCarna_1_1presets_1_1MIPStage.html" title="Renders maximum intensity projections of volume geometries in the scene. " alt="" coords="792,173,967,200"/>
<area shape="rect" id="node2" href="classCarna_1_1base_1_1GeometryStage.html" title="Carna::base::GeometryStage\l\&lt; base::Renderable::BackToFront \&gt;" alt="" coords="231,78,461,119"/>
<area shape="rect" id="node3" href="classCarna_1_1base_1_1RenderStage.html" title="Base abstract class of each rendering stage. Refer to the documentation of the rendering process..." alt="" coords="5,85,183,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Carna::presets::VolumeRenderingStage:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classCarna_1_1presets_1_1VolumeRenderingStage__coll__graph.png" border="0" usemap="#Carna_1_1presets_1_1VolumeRenderingStage_coll__map" alt="Collaboration graph"/></div>
<map name="Carna_1_1presets_1_1VolumeRenderingStage_coll__map" id="Carna_1_1presets_1_1VolumeRenderingStage_coll__map">
<area shape="rect" id="node2" href="classCarna_1_1base_1_1GeometryStage.html" title="Carna::base::GeometryStage\l\&lt; base::Renderable::BackToFront \&gt;" alt="" coords="300,27,531,69"/>
<area shape="rect" id="node3" href="classCarna_1_1base_1_1RenderStage.html" title="Base abstract class of each rendering stage. Refer to the documentation of the rendering process..." alt="" coords="32,5,209,32"/>
<area shape="rect" id="node4" href="classCarna_1_1base_1_1RenderQueue.html" title="Carna::base::RenderQueue\l\&lt; base::Renderable::BackToFront \&gt;" alt="" coords="5,57,236,98"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8bf2ba4b661028e596b17b58d3788e62"><td class="memItemLeft" align="right" valign="top"><a id="a8bf2ba4b661028e596b17b58d3788e62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a8bf2ba4b661028e596b17b58d3788e62">VolumeRenderingStage</a> (unsigned int <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a05fa7ad09a3e539f005b6d9ecde78846">geometryType</a>)</td></tr>
<tr class="memdesc:a8bf2ba4b661028e596b17b58d3788e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates. The created stage will render such <a class="el" href="classCarna_1_1base_1_1Geometry.html">base::Geometry</a> scene graph nodes, whose <a class="el" href="index.html#GeometryTypes">geometry types</a> equal <em>geometryType</em>. <br /></td></tr>
<tr class="separator:a8bf2ba4b661028e596b17b58d3788e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c49b97e8da62b8d8de9a7103c5d910"><td class="memItemLeft" align="right" valign="top"><a id="a11c49b97e8da62b8d8de9a7103c5d910"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a11c49b97e8da62b8d8de9a7103c5d910">~VolumeRenderingStage</a> ()</td></tr>
<tr class="memdesc:a11c49b97e8da62b8d8de9a7103c5d910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes. <br /></td></tr>
<tr class="separator:a11c49b97e8da62b8d8de9a7103c5d910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ee1cdd65ea8c8fcc86beb1d35c6fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a1c7ee1cdd65ea8c8fcc86beb1d35c6fa">setSampleRate</a> (unsigned int <a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a2e10a2e04334272c8ef7e4e415c6264e">sampleRate</a>)</td></tr>
<tr class="memdesc:a1c7ee1cdd65ea8c8fcc86beb1d35c6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of slices to be rendered per segment.  <a href="#a1c7ee1cdd65ea8c8fcc86beb1d35c6fa">More...</a><br /></td></tr>
<tr class="separator:a1c7ee1cdd65ea8c8fcc86beb1d35c6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e10a2e04334272c8ef7e4e415c6264e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a2e10a2e04334272c8ef7e4e415c6264e">sampleRate</a> () const</td></tr>
<tr class="memdesc:a2e10a2e04334272c8ef7e4e415c6264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells number of slices to be rendered per segment.  <a href="#a2e10a2e04334272c8ef7e4e415c6264e">More...</a><br /></td></tr>
<tr class="separator:a2e10a2e04334272c8ef7e4e415c6264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86041fd886f7e19479795e7f9983c483"><td class="memItemLeft" align="right" valign="top"><a id="a86041fd886f7e19479795e7f9983c483"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a86041fd886f7e19479795e7f9983c483">renderPass</a> (const <a class="el" href="namespaceCarna_1_1base_1_1math.html#a991a0f5376e1e66d3d97eafed6d057ef">base::math::Matrix4f</a> &amp;viewTransform, <a class="el" href="classCarna_1_1base_1_1RenderTask.html">base::RenderTask</a> &amp;rt, const <a class="el" href="classCarna_1_1base_1_1Viewport.html">base::Viewport</a> &amp;vp) override</td></tr>
<tr class="memdesc:a86041fd886f7e19479795e7f9983c483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the <a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#VolumeRenderingApproach">volume rendering</a>. <br /></td></tr>
<tr class="separator:a86041fd886f7e19479795e7f9983c483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCarna_1_1base_1_1GeometryStage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCarna_1_1base_1_1GeometryStage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCarna_1_1base_1_1GeometryStage.html">Carna::base::GeometryStage&lt; base::Renderable::BackToFront &gt;</a></td></tr>
<tr class="memitem:a98733d0736e18fdcddb8c1069d382a68 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a98733d0736e18fdcddb8c1069d382a68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a98733d0736e18fdcddb8c1069d382a68">GeometryStage</a> (unsigned int <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a05fa7ad09a3e539f005b6d9ecde78846">geometryType</a>, unsigned int <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#aec1cd4806178b857071f70a1f18e25e6">geometryTypeMask</a>=<a class="el" href="classCarna_1_1base_1_1RenderQueue.html">RenderQueue</a>&lt; <a class="el" href="classCarna_1_1base_1_1Renderable.html#ad444cef24fd4005d14bdbaf352cff053">base::Renderable::BackToFront</a> &gt;::EXACT_MATCH_GEOMETRY_TYPE_MASK)</td></tr>
<tr class="memdesc:a98733d0736e18fdcddb8c1069d382a68 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates s.t. the <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a19f72e739017069d2280801be2e5b20f">predefined rendering queue</a> enqueues such <a class="el" href="classCarna_1_1base_1_1Geometry.html">Carna::base::Geometry</a> scene graph nodes, whose geometry type <em>AND</em>-linked with <em>geometryTypeMask</em> equals the <em>geometryType</em> specified here. <br /></td></tr>
<tr class="separator:a98733d0736e18fdcddb8c1069d382a68 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee5dac700ce96488541848edde9a28e inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a2ee5dac700ce96488541848edde9a28e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a2ee5dac700ce96488541848edde9a28e">~GeometryStage</a> ()</td></tr>
<tr class="memdesc:a2ee5dac700ce96488541848edde9a28e inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases acquired video resources. <br /></td></tr>
<tr class="separator:a2ee5dac700ce96488541848edde9a28e inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b7b4eba3731b69041b17c8131190e1 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a23b7b4eba3731b69041b17c8131190e1">prepareFrame</a> (<a class="el" href="classCarna_1_1base_1_1Node.html">Node</a> &amp;root) override</td></tr>
<tr class="memdesc:a23b7b4eba3731b69041b17c8131190e1 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called once before each frame.  <a href="classCarna_1_1base_1_1GeometryStage.html#a23b7b4eba3731b69041b17c8131190e1">More...</a><br /></td></tr>
<tr class="separator:a23b7b4eba3731b69041b17c8131190e1 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5162e45a98c86b5cf63ec39e6352bac inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="ad5162e45a98c86b5cf63ec39e6352bac"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#ad5162e45a98c86b5cf63ec39e6352bac">renderedPassesCount</a> () const</td></tr>
<tr class="memdesc:ad5162e45a98c86b5cf63ec39e6352bac inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the number of <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a92cf426f3d2b7c4f917103ddd110676f">passes rendered so far</a> since the <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a23b7b4eba3731b69041b17c8131190e1">beginning of the current frame</a>. <br /></td></tr>
<tr class="separator:ad5162e45a98c86b5cf63ec39e6352bac inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a41e16197f44711b83839cc9733b51 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="ac7a41e16197f44711b83839cc9733b51"></a>
GeometryFeatureType::ManagedInterface &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#ac7a41e16197f44711b83839cc9733b51">videoResource</a> (GeometryFeatureType &amp;geometryFeature) const</td></tr>
<tr class="memdesc:ac7a41e16197f44711b83839cc9733b51 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interfaces the <em>geometryFeature</em> video resources that were acquired by this rendering stage. <br /></td></tr>
<tr class="separator:ac7a41e16197f44711b83839cc9733b51 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e705c44373111f533e056ba2827aaf4 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top">const GeometryFeatureType::ManagedInterface &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a9e705c44373111f533e056ba2827aaf4">videoResource</a> (const GeometryFeatureType &amp;geometryFeature) const</td></tr>
<tr class="separator:a9e705c44373111f533e056ba2827aaf4 inherit pub_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCarna_1_1base_1_1RenderStage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCarna_1_1base_1_1RenderStage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCarna_1_1base_1_1RenderStage.html">Carna::base::RenderStage</a></td></tr>
<tr class="memitem:a9273873378498ab5258d10121285978a inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="a9273873378498ab5258d10121285978a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a9273873378498ab5258d10121285978a">RenderStage</a> ()</td></tr>
<tr class="memdesc:a9273873378498ab5258d10121285978a inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates in enabled-state. <br /></td></tr>
<tr class="separator:a9273873378498ab5258d10121285978a inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203b394dde3169bf2217fcdee0f414a2 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="a203b394dde3169bf2217fcdee0f414a2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a203b394dde3169bf2217fcdee0f414a2">~RenderStage</a> ()</td></tr>
<tr class="memdesc:a203b394dde3169bf2217fcdee0f414a2 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes. <br /></td></tr>
<tr class="separator:a203b394dde3169bf2217fcdee0f414a2 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456d4a6922ba548f155e9bd9dc1a5a9 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCarna_1_1base_1_1RenderStage.html">RenderStage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a5456d4a6922ba548f155e9bd9dc1a5a9">clone</a> () const =0</td></tr>
<tr class="memdesc:a5456d4a6922ba548f155e9bd9dc1a5a9 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns same <code>RenderStage</code> implementation with same configuration.  <a href="classCarna_1_1base_1_1RenderStage.html#a5456d4a6922ba548f155e9bd9dc1a5a9">More...</a><br /></td></tr>
<tr class="separator:a5456d4a6922ba548f155e9bd9dc1a5a9 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce4c605ca0637c98e807d8419a30729 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a6ce4c605ca0637c98e807d8419a30729">setViewTransformFixed</a> (bool viewTransformFixed)</td></tr>
<tr class="memdesc:a6ce4c605ca0637c98e807d8419a30729 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the view transform is pass-invariant for the duration of a single frame.  <a href="classCarna_1_1base_1_1RenderStage.html#a6ce4c605ca0637c98e807d8419a30729">More...</a><br /></td></tr>
<tr class="separator:a6ce4c605ca0637c98e807d8419a30729 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a116a4ac99e4538d35f39807f35b308 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="a2a116a4ac99e4538d35f39807f35b308"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a2a116a4ac99e4538d35f39807f35b308">isViewTransformFixed</a> () const</td></tr>
<tr class="memdesc:a2a116a4ac99e4538d35f39807f35b308 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the view transform is pass-invariant for the duration of a single frame. <br /></td></tr>
<tr class="separator:a2a116a4ac99e4538d35f39807f35b308 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373b278fc33c72faca6e98931196cf42 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a373b278fc33c72faca6e98931196cf42">reshape</a> (<a class="el" href="classCarna_1_1base_1_1FrameRenderer.html">FrameRenderer</a> &amp;fr, unsigned int width, unsigned int height)</td></tr>
<tr class="memdesc:a373b278fc33c72faca6e98931196cf42 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders this stage to reshape its buffers according to the specified dimensions.  <a href="classCarna_1_1base_1_1RenderStage.html#a373b278fc33c72faca6e98931196cf42">More...</a><br /></td></tr>
<tr class="separator:a373b278fc33c72faca6e98931196cf42 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d94798371265efb80ba9312fd75717 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#ab0d94798371265efb80ba9312fd75717">isInitialized</a> () const</td></tr>
<tr class="memdesc:ab0d94798371265efb80ba9312fd75717 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether this stage is ready for rendering.  <a href="classCarna_1_1base_1_1RenderStage.html#ab0d94798371265efb80ba9312fd75717">More...</a><br /></td></tr>
<tr class="separator:ab0d94798371265efb80ba9312fd75717 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65584bbfbea6a297e501338103bca338 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="a65584bbfbea6a297e501338103bca338"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a65584bbfbea6a297e501338103bca338">isEnabled</a> () const</td></tr>
<tr class="memdesc:a65584bbfbea6a297e501338103bca338 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether this stage is enabled. Disabled stages are not rendered by <a class="el" href="classCarna_1_1base_1_1RenderTask.html">render tasks</a>. <br /></td></tr>
<tr class="separator:a65584bbfbea6a297e501338103bca338 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4c57f45acf3d427e0e2852bc0fc569 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="a3d4c57f45acf3d427e0e2852bc0fc569"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a3d4c57f45acf3d427e0e2852bc0fc569">setEnabled</a> (bool)</td></tr>
<tr class="memdesc:a3d4c57f45acf3d427e0e2852bc0fc569 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this stage is enabled. Disabled stages are not rendered by <a class="el" href="classCarna_1_1base_1_1RenderTask.html">render tasks</a>. <br /></td></tr>
<tr class="separator:a3d4c57f45acf3d427e0e2852bc0fc569 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb1002b162542d1495981098322f1d inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCarna_1_1base_1_1FrameRenderer.html">base::FrameRenderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#aa6bb1002b162542d1495981098322f1d">renderer</a> ()</td></tr>
<tr class="memdesc:aa6bb1002b162542d1495981098322f1d inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">References the renderer this stage belongs to.  <a href="classCarna_1_1base_1_1RenderStage.html#aa6bb1002b162542d1495981098322f1d">More...</a><br /></td></tr>
<tr class="separator:aa6bb1002b162542d1495981098322f1d inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565d8062404a8f2d8ddca5bff82a7863 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCarna_1_1base_1_1FrameRenderer.html">base::FrameRenderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#a565d8062404a8f2d8ddca5bff82a7863">renderer</a> () const</td></tr>
<tr class="separator:a565d8062404a8f2d8ddca5bff82a7863 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1876aa366047a9e11f44f2fbc80c4c6 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="af1876aa366047a9e11f44f2fbc80c4c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#af1876aa366047a9e11f44f2fbc80c4c6">addRenderStageListener</a> (<a class="el" href="classCarna_1_1base_1_1RenderStageListener.html">RenderStageListener</a> &amp;listener)</td></tr>
<tr class="memdesc:af1876aa366047a9e11f44f2fbc80c4c6 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>listener</em> to the set of listeners this instance notifies in \(\mathcal O\left(\log n\right)\). <br /></td></tr>
<tr class="separator:af1876aa366047a9e11f44f2fbc80c4c6 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace81efe8e397cfeeef66235281d6f163 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memItemLeft" align="right" valign="top"><a id="ace81efe8e397cfeeef66235281d6f163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1RenderStage.html#ace81efe8e397cfeeef66235281d6f163">removeRenderStageListener</a> (<a class="el" href="classCarna_1_1base_1_1RenderStageListener.html">RenderStageListener</a> &amp;listener)</td></tr>
<tr class="memdesc:ace81efe8e397cfeeef66235281d6f163 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>listener</em> from the set of listeners this instance notifies in \(\mathcal O\left(\log n\right)\). <br /></td></tr>
<tr class="separator:ace81efe8e397cfeeef66235281d6f163 inherit pub_methods_classCarna_1_1base_1_1RenderStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9f7a5cbbdb68dcaac5ce451bf9a0a1cc"><td class="memItemLeft" align="right" valign="top"><a id="a9f7a5cbbdb68dcaac5ce451bf9a0a1cc"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a9f7a5cbbdb68dcaac5ce451bf9a0a1cc">DEFAULT_SAMPLE_RATE</a> = 100</td></tr>
<tr class="memdesc:a9f7a5cbbdb68dcaac5ce451bf9a0a1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the default number of slices rendered per segment. <br /></td></tr>
<tr class="separator:a9f7a5cbbdb68dcaac5ce451bf9a0a1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f2cb60428ae677fd4a5303c25703052"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a4f2cb60428ae677fd4a5303c25703052">loadVideoResources</a> ()</td></tr>
<tr class="memdesc:a4f2cb60428ae677fd4a5303c25703052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads video resources when rendering is triggered for the first time. Override this method if you need any additional resources to be loaded, but always call the base implementation.  <a href="#a4f2cb60428ae677fd4a5303c25703052">More...</a><br /></td></tr>
<tr class="separator:a4f2cb60428ae677fd4a5303c25703052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b98bea311d6e87f0bfbbf04c66c0ea"><td class="memItemLeft" align="right" valign="top"><a id="a99b98bea311d6e87f0bfbbf04c66c0ea"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a99b98bea311d6e87f0bfbbf04c66c0ea">render</a> (const <a class="el" href="classCarna_1_1base_1_1Renderable.html">base::Renderable</a> &amp;) override</td></tr>
<tr class="memdesc:a99b98bea311d6e87f0bfbbf04c66c0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the <em>renderable</em>. <br /></td></tr>
<tr class="separator:a99b98bea311d6e87f0bfbbf04c66c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b058684e26cc198d547a863acf0bab"><td class="memItemLeft" align="right" valign="top"><a id="a46b058684e26cc198d547a863acf0bab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a46b058684e26cc198d547a863acf0bab">createVolumeSamplers</a> (const std::function&lt; void(unsigned int, <a class="el" href="classCarna_1_1base_1_1Sampler.html">base::Sampler</a> *) &gt; &amp;registerSampler)=0</td></tr>
<tr class="memdesc:a46b058684e26cc198d547a863acf0bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="classCarna_1_1base_1_1Sampler.html">texture samplers</a> for volume textures and uses <em>registerSampler</em> to assign them to the roles that they should be used with. <br /></td></tr>
<tr class="separator:a46b058684e26cc198d547a863acf0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d31beaa4480c7ab468b0463e7696d"><td class="memItemLeft" align="right" valign="top"><a id="a938d31beaa4480c7ab468b0463e7696d"></a>
virtual const <a class="el" href="classCarna_1_1base_1_1ShaderProgram.html">base::ShaderProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a938d31beaa4480c7ab468b0463e7696d">acquireShader</a> ()=0</td></tr>
<tr class="memdesc:a938d31beaa4480c7ab468b0463e7696d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the shader from the <a class="el" href="classCarna_1_1base_1_1ShaderManager.html">base::ShaderManager</a>, that is to be used for <a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#VolumeRenderingAlgorithm">rendering the slices</a>. <br /></td></tr>
<tr class="separator:a938d31beaa4480c7ab468b0463e7696d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95783a599bfaf57c85dd94a2d91725eb"><td class="memItemLeft" align="right" valign="top"><a id="a95783a599bfaf57c85dd94a2d91725eb"></a>
virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a95783a599bfaf57c85dd94a2d91725eb">uniformName</a> (unsigned int role) const =0</td></tr>
<tr class="memdesc:a95783a599bfaf57c85dd94a2d91725eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the name of the uniform variable, that the <em>role</em> texture is to be bound to. Use <a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a4765b3c371adc7c42207edbed31d0d38">configureShader</a> for custom shader configuration that goes beyond that. <br /></td></tr>
<tr class="separator:a95783a599bfaf57c85dd94a2d91725eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4765b3c371adc7c42207edbed31d0d38"><td class="memItemLeft" align="right" valign="top"><a id="a4765b3c371adc7c42207edbed31d0d38"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a4765b3c371adc7c42207edbed31d0d38">configureShader</a> ()=0</td></tr>
<tr class="memdesc:a4765b3c371adc7c42207edbed31d0d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs custom shader configuration on a per-pass level. <br /></td></tr>
<tr class="separator:a4765b3c371adc7c42207edbed31d0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72e5737232010bc5230db5aa2d82959"><td class="memItemLeft" align="right" valign="top"><a id="af72e5737232010bc5230db5aa2d82959"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#af72e5737232010bc5230db5aa2d82959">configureShader</a> (const <a class="el" href="classCarna_1_1base_1_1Renderable.html">base::Renderable</a> &amp;)=0</td></tr>
<tr class="memdesc:af72e5737232010bc5230db5aa2d82959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs custom shader configuration on a per-volume level. <br /></td></tr>
<tr class="separator:af72e5737232010bc5230db5aa2d82959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classCarna_1_1base_1_1GeometryStage"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classCarna_1_1base_1_1GeometryStage')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classCarna_1_1base_1_1GeometryStage.html">Carna::base::GeometryStage&lt; base::Renderable::BackToFront &gt;</a></td></tr>
<tr class="memitem:a2203d2913d493bef1e530f5807dbade4 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a2203d2913d493bef1e530f5807dbade4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a2203d2913d493bef1e530f5807dbade4">activateGLContext</a> () const</td></tr>
<tr class="memdesc:a2203d2913d493bef1e530f5807dbade4 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <a class="el" href="classCarna_1_1base_1_1GLContext.html">OpenGL context</a> of the hosting <a class="el" href="classCarna_1_1base_1_1FrameRenderer.html">Carna::base::FrameRenderer</a> is the current one. <br /></td></tr>
<tr class="separator:a2203d2913d493bef1e530f5807dbade4 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe86e58ba7d83e4f7c78dafbf9fb02 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a9dfe86e58ba7d83e4f7c78dafbf9fb02"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a9dfe86e58ba7d83e4f7c78dafbf9fb02">buildRenderQueues</a> (<a class="el" href="classCarna_1_1base_1_1Node.html">Node</a> &amp;root, const <a class="el" href="namespaceCarna_1_1base_1_1math.html#a991a0f5376e1e66d3d97eafed6d057ef">math::Matrix4f</a> &amp;viewTransform)</td></tr>
<tr class="memdesc:a9dfe86e58ba7d83e4f7c78dafbf9fb02 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the rendering queues of this stage. <br /></td></tr>
<tr class="separator:a9dfe86e58ba7d83e4f7c78dafbf9fb02 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ba5c71c663ea7f93501b22ba692ae1 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a78ba5c71c663ea7f93501b22ba692ae1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a78ba5c71c663ea7f93501b22ba692ae1">rewindRenderQueues</a> ()</td></tr>
<tr class="memdesc:a78ba5c71c663ea7f93501b22ba692ae1 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds the rendering queues of this stage. <br /></td></tr>
<tr class="separator:a78ba5c71c663ea7f93501b22ba692ae1 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb14ab3e52d2b433af0d73d8bd9b1834 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="afb14ab3e52d2b433af0d73d8bd9b1834"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#afb14ab3e52d2b433af0d73d8bd9b1834">updateRenderQueues</a> (const <a class="el" href="namespaceCarna_1_1base_1_1math.html#a991a0f5376e1e66d3d97eafed6d057ef">math::Matrix4f</a> &amp;viewTransform)</td></tr>
<tr class="memdesc:afb14ab3e52d2b433af0d73d8bd9b1834 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recomputes the <a class="el" href="CoordinateSystems.html#ViewSpace">model-view transforms</a> of the renderables enqueued by this stage. <br /></td></tr>
<tr class="separator:afb14ab3e52d2b433af0d73d8bd9b1834 inherit pro_methods_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classCarna_1_1base_1_1GeometryStage"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classCarna_1_1base_1_1GeometryStage')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classCarna_1_1base_1_1GeometryStage.html">Carna::base::GeometryStage&lt; base::Renderable::BackToFront &gt;</a></td></tr>
<tr class="memitem:a05fa7ad09a3e539f005b6d9ecde78846 inherit pub_attribs_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a05fa7ad09a3e539f005b6d9ecde78846"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a05fa7ad09a3e539f005b6d9ecde78846">geometryType</a></td></tr>
<tr class="memdesc:a05fa7ad09a3e539f005b6d9ecde78846 inherit pub_attribs_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders such geometries whose type <em>AND</em>-linked with <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#aec1cd4806178b857071f70a1f18e25e6">geometryTypeMask</a> equals this. <br /></td></tr>
<tr class="separator:a05fa7ad09a3e539f005b6d9ecde78846 inherit pub_attribs_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1cd4806178b857071f70a1f18e25e6 inherit pub_attribs_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="aec1cd4806178b857071f70a1f18e25e6"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#aec1cd4806178b857071f70a1f18e25e6">geometryTypeMask</a></td></tr>
<tr class="memdesc:aec1cd4806178b857071f70a1f18e25e6 inherit pub_attribs_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders such geometries whose type <em>AND</em>-linked with this equals <a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a05fa7ad09a3e539f005b6d9ecde78846">geometryType</a>. <br /></td></tr>
<tr class="separator:aec1cd4806178b857071f70a1f18e25e6 inherit pub_attribs_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classCarna_1_1base_1_1GeometryStage"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classCarna_1_1base_1_1GeometryStage')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classCarna_1_1base_1_1GeometryStage.html">Carna::base::GeometryStage&lt; base::Renderable::BackToFront &gt;</a></td></tr>
<tr class="memitem:a19f72e739017069d2280801be2e5b20f inherit pro_attribs_classCarna_1_1base_1_1GeometryStage"><td class="memItemLeft" align="right" valign="top"><a id="a19f72e739017069d2280801be2e5b20f"></a>
<a class="el" href="classCarna_1_1base_1_1RenderQueue.html">RenderQueue</a>&lt; <a class="el" href="classCarna_1_1base_1_1Renderable.html#ad444cef24fd4005d14bdbaf352cff053">base::Renderable::BackToFront</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryStage.html#a19f72e739017069d2280801be2e5b20f">rq</a></td></tr>
<tr class="memdesc:a19f72e739017069d2280801be2e5b20f inherit pro_attribs_classCarna_1_1base_1_1GeometryStage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the predefined rendering queue of this rendering stage. <br /></td></tr>
<tr class="separator:a19f72e739017069d2280801be2e5b20f inherit pro_attribs_classCarna_1_1base_1_1GeometryStage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines abstract base class for <a class="el" href="classCarna_1_1base_1_1RenderStage.html">rendering stages</a> that render volume geometries in the scene. </p>
<p>The necessity to evaluate \(f\left(x_i\right)\) for equidistant samples \(x_i\) of a ray, that is shot from each pixel of the screen into the volume geometries of the scene, is common to the typical volume rendering applications like <em>digital radiograph reconstructs</em>, <em>maximum intensity projections</em> or <em>direct volume renderings</em>.</p>
<h1><a class="anchor" id="VolumeRenderingApproach"></a>
Approach</h1>
<p>The approach, that probably seems most natural, is the following. By rendering a bounding box around the volume, we would get an invocation of a fragment shader for each such pixel whose ray intersects the volume. The next step would be to somehow obtain the first and last intersection locations \(x_1\) and \(x_n\) respectively within the shader. Finally one would iterate over the equidistant samples \(x_i\) and evaluate them through \(f\).</p>
<p>This actually is a very wide-spread approach to volume rendering, that is called <em>ray marching</em>. It has two disadvantages. First, the looping within the fragment shader comes at the cost of heavy dynamic branching, that slows down the GPU a lot. Second, it requires quite a lot of shader logic to be implemented redundantly for each application. For this two reasons, this class uses a different approach, but one that is certainly inspired by ray marching.</p>
<div class="image">
<img src="VolumeRenderingApproach.png" alt="VolumeRenderingApproach.png"/>
<div class="caption">
on the left: the ray marching approach - on the right: algorithm implemented here</div></div>
<p> The idea is to use <em>precomputed</em> sample locations. Therefor the samples \(x_i\) of different rays but with same \(i\) are identified as <em>slices</em>. The creation of a mesh that consists of \(n\) slices is easy. The challenge is to position and scale that mesh s.t. it covers the whole volume, i.e. its bounding box like illustrated in the figure above, irrespectively of the view direction. The mesh is oriented s.t. the slices become orthogonal to the viewing direction. It is positioned s.t. its center matches the center of the bounding box. The scaling is a little tricky: We stretch it s.t. it becomes the minimum boundary box to the volume's <em>bounding ellipsoid</em>.</p>
<h1><a class="anchor" id="VolumeRenderingAlgorithm"></a>
Algorithm</h1>
<p>This is an abstract base class for volume rendering stages. The algorithm constructs a sequence of slices. These slices are rendered at the location of every <a class="el" href="classCarna_1_1base_1_1Geometry.html">base::Geometry</a> node <a class="el" href="index.html#GeometryTypes">that this stage processes</a>. The rendering is done s.t. the slices always face exactly towards the camera. Implementations of this class must provide shader that satisfies specific requirements.</p>
<dl class="section see"><dt>See also</dt><dd>A short introduction to shaders is given in the <a class="el" href="classCarna_1_1base_1_1Material.html#CustomMaterials">Custom Materials</a> section.</dd></dl>
<p>It is within the responsibility of this shader to transform the vertices of the slices s.t. they are put in place correctly. Furthermore it is of course the job of the shader to do the texturing of the slices. This abstract class supports the shader in accomplishing both requirements, as explained below.</p>
<h2><a class="anchor" id="VolumeRenderingTransformations"></a>
Transformations</h2>
<p>The vertices of the slices mesh are defined in <em>tangent space</em> coordinates. The z-coordinate is the same for the vertices of a single slice and grows for slices that will be rendered closer to the camera. As usual, rendering requires the transformations of vertices to <a class="el" href="CoordinateSystems.html">eye space and beyond</a>. This is done in two steps:</p>
<ol type="1">
<li>The vertices are transformed to the <em>model space</em> of the geometry node. These coordinates will also be used for texturing, as explained later.</li>
<li>From <em>model space</em> the coordinates are than transformed to <a class="el" href="CoordinateSystems.html#ClippingCoordinates">clipping coordinates</a> as it is always done.</li>
</ol>
<h3><a class="anchor" id="VolumeRenderingTangentModel"></a>
Tangent to Model</h3>
<p>This class computes a matrix that accomplishes the transformation from tangent space to model space. This is pretty easy: The vector of the view direction, transformed to model space by the inverse model-view matrix, is picked as the the <em>normal</em> vector of the tangent space, i.e. the z-component basis vector.</p>
<p>Note that we do not have any requirements upon how the vertices shall be rotated within the plane, the normal vector defines, as long as their rotation is consistent with the texturing. Thus an <a class="el" href="namespaceCarna_1_1base_1_1math.html#a17c3d5319c37633f7e19e0f06957ef91">arbitrary orthogonal vector</a> is constructed, that is taken as the <em>tangent</em>, i.e. the x-component basis vector. The <em>bitangent</em> vector for the y-component is than easily obtained by the cross product of the others two.</p>
<p>The finished <em>tangent-model matrix</em> is uploaded to the shader as an uniform named <code>tangentModel</code> from type <code>mat4</code>.</p>
<h3><a class="anchor" id="VolumeRenderingModelTexture"></a>
Model to Texture</h3>
<p>The volumetric data that is attached to a geometry node is always assumed to be centered within the node. Furthermore the data is scaled s.t. it shapes an unitary cube. This is convenient because OpenGL requires us to specify texture coordinates within \(\left[0, 1\right]^3\). This is why the transformation of model coordinates to texture coordinates requires us to translate the model coordinates by \(\left(0{,}5, 0{,}5, 0{,}5\right)^\mathrm T\) first.</p>
<p>One has to know that a texture, when it is applied to a triangle or a quad, induces a grid of <em>equally</em> sized cells. The question arises, where exactly the values from the texture were mapped to. The answer is, that they are mapped to the cell <em>centers</em> and not the grid intersections, as one might expect. As a consequence, not only the values in between of the texture values are interpolated, but also the values on the edges of the texture. These extrapolated edges are usually not expected by applications. This class <a class="el" href="classCarna_1_1base_1_1ManagedTexture3D.html#a1f01e107690c2a797c5d43b2073852a1">obtains a matrix</a> that shifts and scales the texture coordinates s.t. these edges are avoided. It creates the illusion as if the texture values were actually mapped to the grid intersections.</p>
<p>The matrix, that results from the concatenation of the translation and the edges-correction matrix, is uploaded to the shader as an uniform named <code>modelTexture</code> from type <code>mat4</code>.</p>
<h2><a class="anchor" id="VolumeRenderingOrder"></a>
Rendering</h2>
<p>Usually volume data is partitioned into smaller textures. This reduces the probability of out-of-memory exceptions due to memory fragmentation. The <a class="el" href="classCarna_1_1helpers_1_1VolumeGridHelper.html">helpers::VolumeGridHelper</a> class performs such a partitioning. This means that we will often render not only single volumes but <em>grids</em> where each cell is made up by a volume that needs to be rendered. The algorithm presented here suits this use-case without compromises. However, additional measures need to be taken to avoid artifacts when adjacent cells, i.e. volumes, are rendered. We will go through the two types of artifacts that may arise, look at their causes and how this class avoids them.</p>
<h3><a class="anchor" id="VolumeRenderingAdjacencyArtifacts"></a>
Adjacency Artifacts</h3>
<p>The first type of artifacts encounters when \(f\left(x_i\right)\) are somehow accumulated, like for digital radiograph reconstructs or direct volume renderings. As the figure below illustrates, voxels on the volume edges may be sampled with a higher rate, because the same voxel is processed twice, once when rendering the left volume and once when rendering the right one. This causes faulty accumulated results.</p>
<div class="image">
<img src="VolumeRenderingArtifacts1.png" alt="VolumeRenderingArtifacts1.png"/>
<div class="caption">
on the left: artifacts when rendering without depth test/write - on the right: how these artifacts are caused</div></div>
<p> The solution is rather simple:</p>
<ul>
<li>We ensure that for each volume the slices are rendered from back to front. This is easy to achieve when payed attention to during the mesh creation.</li>
<li>We also ensure that the volumes are rendered from back to front, like it is a common practice for rendering transparent geometries.</li>
<li>Finally we turn on depth testing and depth writing. This ensures that edge voxels are only processed once.</li>
</ul>
<h3><a class="anchor" id="VolumeRenderingOcclusionArtifacts"></a>
Occlusion Artifacts</h3>
<p>The other type of artifacts arises straight from the solution for the first one, depending on how the depth sorting is accomplished. Common implementations compute object distances by evaluating the distance to their centers. If this method was used here, we would observe the artifacts illustrated in the figure below when rendering grid cells of different sizes.</p>
<div class="image">
<img src="VolumeRenderingArtifacts2.png" alt="VolumeRenderingArtifacts2.png"/>
<div class="caption">
on the left: artifacts when using distances to centers - on the right: how these artifacts are caused</div></div>
<p> The term <em>watershed</em> in the picture above refers to an analogy: If the eye is located on the left side, than the left cell is considered closer, otherwise the right cell. The numbers refer to the (reverse) recognized depth order, i.e. the order of rendering the volumes. The watershed, computed from the center-distances, is perfectly fine for equally sized cells, but becomes wrong if one cell is smaller: Here the watershed is shifted to left of where it actually should be. The left cell is rendered first, because the right one is considered closer. This prevents the red-shaded area of the right cell from being rendered afterwards, because the depth test fails in this area.</p>
<p>The solution is to use a different distance measuring. Instead of computing the distances to the cell centers, we compute the <em>actual</em> distances to the cells. The <a class="el" href="structCarna_1_1base_1_1Renderable_1_1DepthOrder.html">depth-sorting implementation</a> does this if an appropriate <a class="el" href="classCarna_1_1base_1_1BoundingBox.html">bounding box</a> is set upon the geometry node. The <a class="el" href="classCarna_1_1helpers_1_1VolumeGridHelper.html">helpers::VolumeGridHelper</a> class configures such bounding boxes for you.</p>
<h1><a class="anchor" id="VolumeRenderingHowToImplementat"></a>
How to Implement</h1>
<p>It is important to have an idea of how shaders access textures. For each texture that a shader is able to read from, it must have an uniform variable declared. It is in the responsibility of the CPU-side program to map such variables to texture units. The uniform variable will then reflect the texture that is currently bound to that unit. For geometry nodes that <a class="el" href="index.html#GeometryTypes">this stage processes</a>, it looks for such <a class="el" href="index.html#GeometryFeatures">geometry features</a> that are from type <a class="el" href="classCarna_1_1base_1_1ManagedTexture3D.html">base::ManagedTexture3D</a>. It then queries the names of the uniform variables, that these textures shall be linked with, from the implementation.</p>
<h2><a class="anchor" id="VolumeRenderingDeriving"></a>
Deriving the Class</h2>
<p>There are four functions that must be implemented:</p>
<ul>
<li><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a938d31beaa4480c7ab468b0463e7696d">acquireShader</a> acquires the shader to be used for <a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#VolumeRenderingAlgorithm">rendering the slices</a>.</li>
<li><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a95783a599bfaf57c85dd94a2d91725eb">uniformName</a> maps the volume texture roles to uniform variable names.</li>
<li><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a4765b3c371adc7c42207edbed31d0d38">configureShader</a> performs arbitrary setup of the shader.</li>
<li><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a46b058684e26cc198d547a863acf0bab">createVolumeSamplers</a> creates <a class="el" href="classCarna_1_1base_1_1Sampler.html">texture samplers</a> and assigns them to the roles that they should be used with.</li>
</ul>
<p>Furthermore, you might want to override <a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a86041fd886f7e19479795e7f9983c483">renderPass</a>. The default implementation invokes the volume rendering algorithm, as it is described above. It is a typical practice for implementations of this class to override this method s.t. it setups a different render target, than invokes the default implementation to render to this target, and finally to process the results by rendering them back to the actually configured output buffer. If alpha blending is used while doing the volume rendering to a dedicated buffer, than this step is frequently referred to as <em>accumulation</em>. For example, the <a class="el" href="classCarna_1_1presets_1_1MIPStage.html">MIPStage</a> accumulates using the <code>GL_MAX</code> <a class="el" href="classCarna_1_1base_1_1RenderState.html#aef78c13cdd8fb4d2c276c19666b600b4">blend equation</a>, or the <a class="el" href="classCarna_1_1presets_1_1DRRStage.html">DRRStage</a> accumulates with <code>GL_ADD</code> to compute an integral.</p>
<h2><a class="anchor" id="VolumeRenderingShader"></a>
Writing the Shader</h2>
<p>Below are a few hints on how to implement the shader. Refer to the <a class="el" href="classCarna_1_1base_1_1Material.html#ShaderMaterialIntegration">Integration into Materials</a> section for hints on how to actually load the shader.</p>
<h3><a class="anchor" id="VolumeRenderingVertexShader"></a>
Vertex Shader</h3>
<p>The vertex shader must declare the following GLSL version, uniform variables and <a class="el" href="structCarna_1_1base_1_1PVertex.html#CustomVertexFormats">vertex formats</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div><div class="line">uniform mat4 tangentModel;</div><div class="line">uniform mat4 modelViewProjection;</div><div class="line"></div><div class="line">layout( location = 0 ) in vec4 inPosition;</div></div><!-- fragment --><p>Furthermore, it must pass the model-space coordinates to the fragment shader, although the name of the variable used for this is arbitrary:</p>
<div class="fragment"><div class="line">out vec4 modelSpaceCoordinates;</div></div><!-- fragment --><p>Most of the time you should be able to stick to this implementation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    modelSpaceCoordinates = tangentModel * inPosition;</div><div class="line">    vec4 clippingCoordinates = modelViewProjection * modelSpaceCoordinates;</div><div class="line">    gl_Position = clippingCoordinates;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="VolumeRenderingFragmentShader"></a>
Fragment Shader</h3>
<p>The fragment shader must declare the following GLSL version and uniform variables, along with a varying for the model-space coordinates, whose name must match the name used in the vertex shader:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 330</span></div><div class="line"></div><div class="line">uniform mat4 modelTexture;</div><div class="line"></div><div class="line">in  vec4 modelSpaceCoordinates;</div><div class="line">out vec4 gl_FragColor;</div></div><!-- fragment --><p>The name of the color output variable <code>gl_FragColor</code> is arbitrary.</p>
<p>Below is the body of a typical implementation of the fragment shader, that writes the texture coordinates to the color output:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>( abs( modelSpaceCoordinates.x ) &gt; 0.5 || abs( modelSpaceCoordinates.y ) &gt; 0.5 || abs( modelSpaceCoordinates.z ) &gt; 0.5 )</div><div class="line">    {</div><div class="line">        discard;</div><div class="line">    }</div><div class="line">    vec4 textureCoordinates = modelTexture * modelSpaceCoordinates;</div><div class="line">    gl_FragColor = vec4( textureCoordinates.rgb, 1 );</div><div class="line">}</div></div><!-- fragment --><p>For a full example on how to implement the shader, refer to the files <a class="el" href="mip_8vert_source.html">src/res/mip.vert</a> and <a class="el" href="mip_8frag_source.html">src/res/mip.frag</a>. These should be self-explaining.</p>
<dl class="section author"><dt>Author</dt><dd>Leonid Kostrykin </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22.2.15 - 23.3.15 </dd></dl>

<p class="definition">Definition at line <a class="el" href="VolumeRenderingStage_8h_source.html#l00316">316</a> of file <a class="el" href="VolumeRenderingStage_8h_source.html">VolumeRenderingStage.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f2cb60428ae677fd4a5303c25703052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2cb60428ae677fd4a5303c25703052">&#9670;&nbsp;</a></span>loadVideoResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Carna::presets::VolumeRenderingStage::loadVideoResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads video resources when rendering is triggered for the first time. Override this method if you need any additional resources to be loaded, but always call the base implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>the first texture unit to use for volume textures. The dafault implementation returns <a class="el" href="classCarna_1_1base_1_1TextureBase.html#a9383ef7089043f4e7c624068a468a21e">base::Texture&lt;0&gt;::SETUP_UNIT</a> <code>+1</code>. </dd></dl>

<p>Reimplemented in <a class="el" href="classCarna_1_1presets_1_1DRRStage.html#a332fbf13046859e78869e6edd7966874">Carna::presets::DRRStage</a>, <a class="el" href="classCarna_1_1presets_1_1DVRStage.html#ad64da1cbd849210e75fb4e81c0616133">Carna::presets::DVRStage</a>, and <a class="el" href="classCarna_1_1presets_1_1MaskRenderingStage.html#aa18f319517ebce8784337a84762c8261">Carna::presets::MaskRenderingStage</a>.</p>

</div>
</div>
<a id="a2e10a2e04334272c8ef7e4e415c6264e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e10a2e04334272c8ef7e4e415c6264e">&#9670;&nbsp;</a></span>sampleRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Carna::presets::VolumeRenderingStage::sampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells number of slices to be rendered per segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="classCarna_1_1presets_1_1VolumeRenderingStage.html#a2e10a2e04334272c8ef7e4e415c6264e" title="Tells number of slices to be rendered per segment. ">sampleRate()</a> &gt;= 2</code> </dd></dl>

</div>
</div>
<a id="a1c7ee1cdd65ea8c8fcc86beb1d35c6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ee1cdd65ea8c8fcc86beb1d35c6fa">&#9670;&nbsp;</a></span>setSampleRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::presets::VolumeRenderingStage::setSampleRate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sampleRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets number of slices to be rendered per segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>sampleRate &gt;= 2</code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/Carna/presets/<a class="el" href="VolumeRenderingStage_8h_source.html">VolumeRenderingStage.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>
    <address class="footer">
        <small>
			Written by <a href="http://evoid.de">Leonid Kostrykin</a> at the
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>
</body>
</html>
