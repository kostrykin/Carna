<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Carna: Carna::base::Material Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doc_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Carna
   &#160;<span id="projectnumber">Version 3.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Carna</b></li><li class="navelem"><a class="el" href="namespaceCarna_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classCarna_1_1base_1_1Material.html">Material</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classCarna_1_1base_1_1Material-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Carna::base::Material Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specifies the <a class="el" href="classCarna_1_1base_1_1ShaderProgram.html">shader</a> and it's configuration that are to be used for rendering a <a class="el" href="classCarna_1_1base_1_1Geometry.html">Geometry</a> node with a <a class="el" href="classCarna_1_1base_1_1MeshRenderingStage.html">MeshRenderingStage</a>. Custom implementations could also tweak the <a class="el" href="classCarna_1_1base_1_1RenderState.html">render state</a>.  
 <a href="classCarna_1_1base_1_1Material.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Material_8h_source.html">Material.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Carna::base::Material:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classCarna_1_1base_1_1Material__inherit__graph.png" border="0" usemap="#Carna_1_1base_1_1Material_inherit__map" alt="Inheritance graph"/></div>
<map name="Carna_1_1base_1_1Material_inherit__map" id="Carna_1_1base_1_1Material_inherit__map">
<area shape="rect" id="node2" href="classCarna_1_1base_1_1GeometryFeature.html" title="Represents &quot;components&quot; that are aggregated by Geometry objects. Closer description is given here..." alt="" coords="5,5,208,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Carna::base::Material:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classCarna_1_1base_1_1Material__coll__graph.png" border="0" usemap="#Carna_1_1base_1_1Material_coll__map" alt="Collaboration graph"/></div>
<map name="Carna_1_1base_1_1Material_coll__map" id="Carna_1_1base_1_1Material_coll__map">
<area shape="rect" id="node2" href="classCarna_1_1base_1_1GeometryFeature.html" title="Represents &quot;components&quot; that are aggregated by Geometry objects. Closer description is given here..." alt="" coords="5,5,208,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material_1_1ManagedInterface.html">ManagedInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an acquisition of video resources from a particular <a class="el" href="classCarna_1_1base_1_1Material.html">Material</a>. This realizes the RAII idiom.  <a href="classCarna_1_1base_1_1Material_1_1ManagedInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad020827c4b185c9a7e55ad7f5886219d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#ad020827c4b185c9a7e55ad7f5886219d">addParameter</a> (<a class="el" href="classCarna_1_1base_1_1ShaderUniformBase.html">ShaderUniformBase</a> *uniform)</td></tr>
<tr class="memdesc:ad020827c4b185c9a7e55ad7f5886219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records <em>uniform</em> as shader parameter. This will be uploaded to the shader when the material is <a class="el" href="classCarna_1_1base_1_1Material_1_1ManagedInterface.html#a5686c09322e4b31425af73da280806ec">activated</a>.  <a href="#ad020827c4b185c9a7e55ad7f5886219d">More...</a><br /></td></tr>
<tr class="separator:ad020827c4b185c9a7e55ad7f5886219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d9fdf1177ae1d03e30f989e727c610"><td class="memTemplParams" colspan="2">template&lt;typename ParameterType &gt; </td></tr>
<tr class="memitem:ab6d9fdf1177ae1d03e30f989e727c610"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#ab6d9fdf1177ae1d03e30f989e727c610">setParameter</a> (const std::string &amp;name, const ParameterType &amp;value)</td></tr>
<tr class="separator:ab6d9fdf1177ae1d03e30f989e727c610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1278b426eb893327579a0002e9142d"><td class="memItemLeft" align="right" valign="top"><a id="a2e1278b426eb893327579a0002e9142d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a2e1278b426eb893327579a0002e9142d">clearParameters</a> ()</td></tr>
<tr class="memdesc:a2e1278b426eb893327579a0002e9142d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all previously set parameters. <br /></td></tr>
<tr class="separator:a2e1278b426eb893327579a0002e9142d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681bf40189e6a34c4977f01d8abdcb4f"><td class="memItemLeft" align="right" valign="top"><a id="a681bf40189e6a34c4977f01d8abdcb4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a681bf40189e6a34c4977f01d8abdcb4f">removeParameter</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a681bf40189e6a34c4977f01d8abdcb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the parameter named <em>name</em> if it exists. <br /></td></tr>
<tr class="separator:a681bf40189e6a34c4977f01d8abdcb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd5c3d4efe3d259bf18f934fc30a877"><td class="memItemLeft" align="right" valign="top"><a id="a2cd5c3d4efe3d259bf18f934fc30a877"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a2cd5c3d4efe3d259bf18f934fc30a877">hasParameter</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a2cd5c3d4efe3d259bf18f934fc30a877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether a paramter named <em>name</em> exists. <br /></td></tr>
<tr class="separator:a2cd5c3d4efe3d259bf18f934fc30a877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25ec0eced293ff6ab40eb77e5f6c9b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCarna_1_1base_1_1ShaderUniformBase.html">ShaderUniformBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#ab25ec0eced293ff6ab40eb77e5f6c9b5">parameter</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab25ec0eced293ff6ab40eb77e5f6c9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">References the paramter named <em>name</em>.  <a href="#ab25ec0eced293ff6ab40eb77e5f6c9b5">More...</a><br /></td></tr>
<tr class="separator:ab25ec0eced293ff6ab40eb77e5f6c9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba89d703a69f581dd26e0818b50f5d7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#aeba89d703a69f581dd26e0818b50f5d7">controlsSameVideoResource</a> (const <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html">GeometryFeature</a> &amp;other) const override</td></tr>
<tr class="memdesc:aeba89d703a69f581dd26e0818b50f5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether this instance maintains the same video resources like <em>other</em>.  <a href="#aeba89d703a69f581dd26e0818b50f5d7">More...</a><br /></td></tr>
<tr class="separator:aeba89d703a69f581dd26e0818b50f5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480da2a388fe2250e92786d8e85c5ed1"><td class="memItemLeft" align="right" valign="top"><a id="a480da2a388fe2250e92786d8e85c5ed1"></a>
virtual <a class="el" href="classCarna_1_1base_1_1Material_1_1ManagedInterface.html">ManagedInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a480da2a388fe2250e92786d8e85c5ed1">acquireVideoResource</a> () override</td></tr>
<tr class="memdesc:a480da2a388fe2250e92786d8e85c5ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the video resources from this <code>GeometryFeature</code> by returning new instance of a class derived from <a class="el" href="classCarna_1_1base_1_1Material_1_1ManagedInterface.html">ManagedInterface</a>, that realizes the RAII idiom. Refer to its documentation for details. May return <code>nullptr</code> if this <code>GeometryFeature</code> does not provide any video resources. <br /></td></tr>
<tr class="separator:a480da2a388fe2250e92786d8e85c5ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCarna_1_1base_1_1GeometryFeature"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCarna_1_1base_1_1GeometryFeature')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html">Carna::base::GeometryFeature</a></td></tr>
<tr class="memitem:a06bf0e7c6abe352a455bf69899036d3e inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memItemLeft" align="right" valign="top"><a id="a06bf0e7c6abe352a455bf69899036d3e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#a06bf0e7c6abe352a455bf69899036d3e">videoResourceAcquisitionsCount</a> () const</td></tr>
<tr class="memdesc:a06bf0e7c6abe352a455bf69899036d3e inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells current number of <a class="el" href="classCarna_1_1base_1_1GeometryFeature_1_1ManagedInterface.html">video resource acquisitions</a>. <br /></td></tr>
<tr class="separator:a06bf0e7c6abe352a455bf69899036d3e inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a90c20723ac0272c713bf15681ca16 inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#a04a90c20723ac0272c713bf15681ca16">release</a> ()</td></tr>
<tr class="memdesc:a04a90c20723ac0272c713bf15681ca16 inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes that this object is no longer required and may be deleted as soon as it is valid to delete it.  <a href="classCarna_1_1base_1_1GeometryFeature.html#a04a90c20723ac0272c713bf15681ca16">More...</a><br /></td></tr>
<tr class="separator:a04a90c20723ac0272c713bf15681ca16 inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ad7e8f9622d1489f114860acb83e81 inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#a66ad7e8f9622d1489f114860acb83e81">addTo</a> (<a class="el" href="classCarna_1_1base_1_1Geometry.html">Geometry</a> &amp;sceneGraphNode, unsigned int role)</td></tr>
<tr class="memdesc:a66ad7e8f9622d1489f114860acb83e81 inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts this geometry feature on the <em>sceneGraphNode</em>.  <a href="classCarna_1_1base_1_1GeometryFeature.html#a66ad7e8f9622d1489f114860acb83e81">More...</a><br /></td></tr>
<tr class="separator:a66ad7e8f9622d1489f114860acb83e81 inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32533faed03735fabd98978d6b0d94db inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#a32533faed03735fabd98978d6b0d94db">removeFrom</a> (<a class="el" href="classCarna_1_1base_1_1Geometry.html">Geometry</a> &amp;sceneGraphNode)</td></tr>
<tr class="memdesc:a32533faed03735fabd98978d6b0d94db inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this geometry feature from the <em>sceneGraphNode</em>.  <a href="classCarna_1_1base_1_1GeometryFeature.html#a32533faed03735fabd98978d6b0d94db">More...</a><br /></td></tr>
<tr class="separator:a32533faed03735fabd98978d6b0d94db inherit pub_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a171cf4340cdda88f4e304e86934cd667"><td class="memItemLeft" align="right" valign="top"><a id="a171cf4340cdda88f4e304e86934cd667"></a>
static <a class="el" href="classCarna_1_1base_1_1Material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a171cf4340cdda88f4e304e86934cd667">create</a> (const std::string &amp;<a class="el" href="classCarna_1_1base_1_1Material.html#a67c7e46635ce517d538196ecb15afd9f">shaderName</a>)</td></tr>
<tr class="memdesc:a171cf4340cdda88f4e304e86934cd667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates. Call <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#a04a90c20723ac0272c713bf15681ca16">release</a> when you do not need the object any longer. <br /></td></tr>
<tr class="separator:a171cf4340cdda88f4e304e86934cd667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a67c7e46635ce517d538196ecb15afd9f"><td class="memItemLeft" align="right" valign="top"><a id="a67c7e46635ce517d538196ecb15afd9f"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a67c7e46635ce517d538196ecb15afd9f">shaderName</a></td></tr>
<tr class="memdesc:a67c7e46635ce517d538196ecb15afd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies this material's shader. <br /></td></tr>
<tr class="separator:a67c7e46635ce517d538196ecb15afd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0e571bb93cac82234d8de709e45ad5c0"><td class="memItemLeft" align="right" valign="top"><a id="a0e571bb93cac82234d8de709e45ad5c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a0e571bb93cac82234d8de709e45ad5c0">Material</a> (const std::string &amp;<a class="el" href="classCarna_1_1base_1_1Material.html#a67c7e46635ce517d538196ecb15afd9f">shaderName</a>)</td></tr>
<tr class="memdesc:a0e571bb93cac82234d8de709e45ad5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates. <br /></td></tr>
<tr class="separator:a0e571bb93cac82234d8de709e45ad5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6982a7c5ad1740d122f4aa23ebd764"><td class="memItemLeft" align="right" valign="top"><a id="a8e6982a7c5ad1740d122f4aa23ebd764"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1Material.html#a8e6982a7c5ad1740d122f4aa23ebd764">~Material</a> ()</td></tr>
<tr class="memdesc:a8e6982a7c5ad1740d122f4aa23ebd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes. <br /></td></tr>
<tr class="separator:a8e6982a7c5ad1740d122f4aa23ebd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classCarna_1_1base_1_1GeometryFeature"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classCarna_1_1base_1_1GeometryFeature')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html">Carna::base::GeometryFeature</a></td></tr>
<tr class="memitem:ad930fd01c3a769a28b19509ad5122188 inherit pro_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memItemLeft" align="right" valign="top"><a id="ad930fd01c3a769a28b19509ad5122188"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#ad930fd01c3a769a28b19509ad5122188">GeometryFeature</a> ()</td></tr>
<tr class="memdesc:ad930fd01c3a769a28b19509ad5122188 inherit pro_methods_classCarna_1_1base_1_1GeometryFeature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates. <br /></td></tr>
<tr class="separator:ad930fd01c3a769a28b19509ad5122188 inherit pro_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bb723233a845182784d9372eab0b0f inherit pro_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memItemLeft" align="right" valign="top"><a id="ab3bb723233a845182784d9372eab0b0f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#ab3bb723233a845182784d9372eab0b0f">~GeometryFeature</a> ()</td></tr>
<tr class="memdesc:ab3bb723233a845182784d9372eab0b0f inherit pro_methods_classCarna_1_1base_1_1GeometryFeature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes and <a class="el" href="classCarna_1_1base_1_1Log.html">logs</a> an error if video resources are leaked. <br /></td></tr>
<tr class="separator:ab3bb723233a845182784d9372eab0b0f inherit pro_methods_classCarna_1_1base_1_1GeometryFeature"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af95b9906314d5cd4d793f754b7cdd6c0"><td class="memItemLeft" align="right" valign="top"><a id="af95b9906314d5cd4d793f754b7cdd6c0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GeometryFeature</b></td></tr>
<tr class="separator:af95b9906314d5cd4d793f754b7cdd6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specifies the <a class="el" href="classCarna_1_1base_1_1ShaderProgram.html">shader</a> and it's configuration that are to be used for rendering a <a class="el" href="classCarna_1_1base_1_1Geometry.html">Geometry</a> node with a <a class="el" href="classCarna_1_1base_1_1MeshRenderingStage.html">MeshRenderingStage</a>. Custom implementations could also tweak the <a class="el" href="classCarna_1_1base_1_1RenderState.html">render state</a>. </p>
<h1><a class="anchor" id="RenderingPipeline"></a>
Rendering Pipeline</h1>
<p>The core part of a material is the shader, which requires a basic understanding of the <em>rendering pipeline</em>. A very good explanation can be found here: <a href="http://www.lighthouse3d.com/tutorials/glsl-core-tutorial/pipeline33/">http://www.lighthouse3d.com/tutorials/glsl-core-tutorial/pipeline33/</a> Nevertheless, lets pass through the most important aspects of the pipeline. The pipeline consists of stages, that are distinguished by whether they are programmable or not. Programmable stages are called <em>shaders</em>.</p>
<ol type="1">
<li>The first stage always is the <em>vertex shader</em> that is invoked once for each vertex from the vertex buffer. It takes one vertex per invocation as input, transforms it and writes it to the output. Typically the output vertices are written as <a class="el" href="CoordinateSystems.html#ClippingCoordinates">clipping coordinates</a>.</li>
<li>Within the <em>primitive assembly stage</em> the vertices are assembled to <em>primitives</em> according to the index buffer.</li>
<li>The optional <em>geometry shader</em> is invoked once for each primitive. For each invocation, it writes an arbitrary number of primitives as output. This means that the geometry shader can be used for culling primitives as well as for the generation of new ones.</li>
<li>The <em>rasterization and interpolation</em> stage maps the primitives on top of a grid, whose cells are called <em>fragments</em>. Fragments are basically pixels, but they are given in <a class="el" href="CoordinateSystems.html#WindowCoordinates">window coordinates</a>, hence they have a depth component in particular.</li>
<li>The <em>fragment shader</em> is invoked once for each fragment of the pritimive. It either writes the fragment's attributes like its color and its depth, or it discards the fragment. It is neither possible to generate new fragments, nor to change other fragment's coordinates but its depth.</li>
<li>The last stage maps the primitive's fragments to the color buffer's <em>pixels</em> by application of <a class="el" href="classCarna_1_1base_1_1RenderState.html#a4937c6ad8796d73fcef6518ebd7d8ac9">alpha blending</a>. It also performs tests, like the <a class="el" href="classCarna_1_1base_1_1RenderState.html#a696fb8fd968f19b8afa63c2d61c7c1f8">depth test</a>, on each fragment.</li>
</ol>
<p>Note that the depth test might be performed within stage 4 already, if stage 5 does not alter the precomputed fragment depth. This is usually faster, because less fragments need to be processed by stage 5.</p>
<h1><a class="anchor" id="CustomMaterials"></a>
Custom Materials</h1>
<p>As already mentioned in the section above, the core part of a material is its shader. A shader, actually the <em>shader program</em>, consists of a <em>vertex shader</em> and a <em>fragment shader</em> at least. It may also have a <em>fragment shader</em>, which is optional. All three of these are explained in the section above.</p>
<p>So the first step in creating a new material most likely will be the implementation of a vertex and a fragment shader.</p>
<h2><a class="anchor" id="GLSL_Vert"></a>
Vertex Shaders</h2>
<p>A typical vertex shader looks like this:</p>
<div class="fragment"><div class="line">#version 330</div><div class="line">uniform mat4 modelViewProjection;</div><div class="line">layout( location = 0 ) in vec4 inPosition;</div><div class="line">void main()</div><div class="line">{</div><div class="line">    vec4 clippingCoordinates = modelViewProjection * inPosition;</div><div class="line">    gl_Position = clippingCoordinates;</div><div class="line">}</div></div><!-- fragment --><p>Line 1 specifies the GLSL version that the compiler should use to build the code. Line 2 declares a variable, whose value will be set from code that runs on the CPU. The keyword <code>uniform</code> reflects the fact the value will be the same for each processed vertex. Line 3 declares the <a class="el" href="structCarna_1_1base_1_1PVertex.html#CustomVertexFormats">vertex format</a>. The <code>main</code> function is invoked for each processed vertex. The example code above assumes that the vertices are stored in <a class="el" href="CoordinateSystems.html#CoordinateTransformations">model space</a> within the vertex buffer and transforms them to <a class="el" href="CoordinateSystems.html#ClippingCoordinates">clipping coordinates</a>.</p>
<p>Following uniform variables will be set by the <code>Material</code> class automatically, if declared:</p>
<ul>
<li><code>modelView</code> takes the model-view transform. This is the concatenation of the <a class="el" href="classCarna_1_1base_1_1Camera.html#abd57dba12e7142ceaf55cadc0c3d0069">view transform</a> and the <a class="el" href="classCarna_1_1base_1_1Spatial.html#aff4479a9de66ca9d622c2f992d2b8ed9">world transform</a>. It maps from model space to view space.</li>
<li><code>projection</code> takes the <a class="el" href="classCarna_1_1base_1_1Camera.html#a5634a4aea02df3702e725bff4a62335e">projection matrix</a> that maps from view space to clipping coordinates.</li>
<li><code>modelViewProjection</code> is the concatenation of <code>projection</code> and <code>modelView</code>. It maps from model space to clipping coordinates.</li>
</ul>
<h2><a class="anchor" id="GLSL_Frag"></a>
Fragment Shaders</h2>
<p>Lets take a look at an exemplary fragment shader:</p>
<div class="fragment"><div class="line">#version 330</div><div class="line">uniform vec4 color;</div><div class="line">out vec4 gl_FragColor;</div><div class="line">void main()</div><div class="line">{</div><div class="line">    gl_FragColor = vec4( color );</div><div class="line">}</div></div><!-- fragment --><p>Line 1 declares the GLSL version, just like it was did for vertex shaders. Vertex and fragment shaders, that are going to be used together as a single <a class="el" href="classCarna_1_1base_1_1ShaderProgram.html">shader program</a> must also use the same GLSL version. Line 2 declares a variable, whose value will be set <a class="el" href="classCarna_1_1base_1_1Material.html#ab6d9fdf1177ae1d03e30f989e727c610">when the shader is triggered</a>. Note that the keyword <code>uniform</code> reflects the same intuitive meaning as it did in the vertex shader example above. Line 3 declares a variable, that the fragment shader will write its output to. You won't need a different declaration than this, unless you are going to render to multiple color buffers at once, which is an advanced technique. Just like for vertex shaders, the <code>main</code> function of the fragment shader will be executed once for each fragment. The shader code above colors the whole rendered object in a <em>uniform</em> color.</p>
<h2><a class="anchor" id="ShaderMaterialIntegration"></a>
Integration into Materials</h2>
<p>The <code>Material</code> class acquires its shader objects from the <a class="el" href="classCarna_1_1base_1_1ShaderManager.html">ShaderManager</a>, which ensures that each shader is built just once and not each time someone requests it. So everything one has to do is to ensure that the <code>ShaderManager</code> will be able to locate the shader sources:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceCarna.html">Carna</a>;</div><div class="line"><a class="code" href="classCarna_1_1base_1_1Singleton.html#a1f55c4604dcdd90886fce91a27fb035a">base::ShaderManager::instance</a>().<a class="code" href="classCarna_1_1base_1_1ShaderManager.html#afdb70514b366005235fff4abc5ec0998">setSource</a>( <span class="stringliteral">&quot;myShader.vert&quot;</span>, srcVert );</div><div class="line"><a class="code" href="classCarna_1_1base_1_1Singleton.html#a1f55c4604dcdd90886fce91a27fb035a">base::ShaderManager::instance</a>().<a class="code" href="classCarna_1_1base_1_1ShaderManager.html#afdb70514b366005235fff4abc5ec0998">setSource</a>( <span class="stringliteral">&quot;myShader.frag&quot;</span>, srcFrag );</div></div><!-- fragment --><p>This needs to be done <em>before</em> the material first tries to acquire the shader, i.e. before the geometry node, the material is attached to, is rendered.</p>
<p>The suffixes <code>.vert</code> and <code>.frag</code> are important. You will be able to reference the shader from a <code>Material</code> object by setting its <code>shaderName</code> to <code>myShader</code>.</p>
<dl class="section author"><dt>Author</dt><dd>Leonid Kostrykin </dd></dl>
<dl class="section date"><dt>Date</dt><dd>22.2.15 - 18.3.15 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Material_8h_source.html#l00174">174</a> of file <a class="el" href="Material_8h_source.html">Material.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad020827c4b185c9a7e55ad7f5886219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad020827c4b185c9a7e55ad7f5886219d">&#9670;&nbsp;</a></span>addParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::base::Material::addParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCarna_1_1base_1_1ShaderUniformBase.html">ShaderUniformBase</a> *&#160;</td>
          <td class="paramname"><em>uniform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Records <em>uniform</em> as shader parameter. This will be uploaded to the shader when the material is <a class="el" href="classCarna_1_1base_1_1Material_1_1ManagedInterface.html#a5686c09322e4b31425af73da280806ec">activated</a>. </p>
<p>Any previously set parameters with the same <a class="el" href="classCarna_1_1base_1_1ShaderUniformBase.html#a6f914de7d1cf50d53bdecc64c5cec3bb">name</a> are overriden. </p>

</div>
</div>
<a id="aeba89d703a69f581dd26e0818b50f5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba89d703a69f581dd26e0818b50f5d7">&#9670;&nbsp;</a></span>controlsSameVideoResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Carna::base::Material::controlsSameVideoResource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html">GeometryFeature</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether this instance maintains the same video resources like <em>other</em>. </p>
<p>This implementation checks whether <em>other</em> also is a <code>Material</code> and if yes, whether its <a class="el" href="classCarna_1_1base_1_1Material.html#a67c7e46635ce517d538196ecb15afd9f">shaderName</a> is the same. </p>

<p>Implements <a class="el" href="classCarna_1_1base_1_1GeometryFeature.html#a27e0393484680950c2f2125f8b90e962">Carna::base::GeometryFeature</a>.</p>

</div>
</div>
<a id="ab25ec0eced293ff6ab40eb77e5f6c9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25ec0eced293ff6ab40eb77e5f6c9b5">&#9670;&nbsp;</a></span>parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCarna_1_1base_1_1ShaderUniformBase.html">ShaderUniformBase</a>&amp; Carna::base::Material::parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References the paramter named <em>name</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>hasParameter(name) == true</code> </dd></dl>

</div>
</div>
<a id="ab6d9fdf1177ae1d03e30f989e727c610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d9fdf1177ae1d03e30f989e727c610">&#9670;&nbsp;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Carna::base::Material::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="Material_8h_source.html#l00306">306</a> of file <a class="el" href="Material_8h_source.html">Material.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/Carna/base/<a class="el" href="Material_8h_source.html">Material.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>
    <address class="footer">
        <small>
			Written by <a href="http://evoid.de">Leonid Kostrykin</a> at the
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>
</body>
</html>
